; FAST Mini Database - Fixed LIKE (SQL-style) + full program
INCLUDE Irvine32.inc

.data
; Configuration
MAX     = 50
STRLEN  = 20        ; bytes per string (including room for null terminator)

; Data arrays: MAX records Ã— STRLEN bytes each
first_name  BYTE MAX * STRLEN DUP(0)
last_name   BYTE MAX * STRLEN DUP(0)
id_array    BYTE MAX * STRLEN DUP(0)
avg         BYTE MAX DUP(0)
attendance  BYTE MAX DUP(0)

countRec    DWORD 0      ; number of records currently stored

; Messages
menuMsg      BYTE "=== FAST Mini Database ===",0Dh,0Ah,0
menu1        BYTE "1. Add Record",0Dh,0Ah,0
menu2        BYTE "2. Display by ID",0Dh,0Ah,0
menu3        BYTE "3. Display All",0Dh,0Ah,0
menu4        BYTE "4. Delete by ID",0Dh,0Ah,0
menu5        BYTE "5. Update Record",0Dh,0Ah,0
menu6        BYTE "6. Count Total Students",0Dh,0Ah,0
menu7        BYTE "7. Clear All Records",0Dh,0Ah,0
menu8        BYTE "8. Exit",0Dh,0Ah,0
menu9        BYTE "9. Search Name (LIKE)",0Dh,0Ah,0
menu10       BYTE "10. Aggregate Functions",0Dh,0Ah,0

promptChoic  BYTE "Enter choice: ",0
savedMsg     BYTE "Saved Information.",0Dh,0Ah,0
notFoundMsg  BYTE "Data For The ID Not Found.",0Dh,0Ah,0
delMsg       BYTE "Record deleted.",0Dh,0Ah,0
updMsg       BYTE "Record updated.",0Dh,0Ah,0
clearMsg     BYTE "All records cleared.",0Dh,0Ah,0
countMsg     BYTE "Total students: ",0

; Add record prompts
addrec1      BYTE "Enter First Name: ",0
addrec2      BYTE "Enter Last Name: ",0
addrec3      BYTE "Enter Nu-ID: ",0
addrec4      BYTE "Enter Attendance Percentage (0-100): ",0
addrec5      BYTE "Enter Average Percentage (0-100): ",0

; Search prompts
searchTypeMsg BYTE "Choose search type:",0Dh,0Ah,0
searchOpt1    BYTE "1. Starts with",0Dh,0Ah,0
searchOpt2    BYTE "2. Ends with",0Dh,0Ah,0
searchOpt3    BYTE "3. Contains",0Dh,0Ah,0
enterSubMsg   BYTE "Enter substring (you may use % and _): ",0

; Aggregate menu prompts
aggrMsg       BYTE "=== Aggregate Functions ===",0Dh,0Ah,0
aggrOpt1      BYTE "1. MIN()",0Dh,0Ah,0
aggrOpt2      BYTE "2. MAX()",0Dh,0Ah,0
aggrOpt3      BYTE "3. COUNT()",0Dh,0Ah,0
aggrOpt4      BYTE "4. AVG()",0Dh,0Ah,0
colMsg        BYTE "Select column: 1 = Attendance, 2 = Marks (avg): ",0

; Buffers
inputBuffer  BYTE 50 DUP(0)
patternBuf   BYTE STRLEN+2 DUP(0)    ; buffer to build pattern (allow adding %)

.code
main PROC
main_loop:
    ; Show menu
    mov edx, OFFSET menuMsg
    call WriteString
    mov edx, OFFSET menu1
    call WriteString
    mov edx, OFFSET menu2
    call WriteString
    mov edx, OFFSET menu3
    call WriteString
    mov edx, OFFSET menu4
    call WriteString
    mov edx, OFFSET menu5
    call WriteString
    mov edx, OFFSET menu6
    call WriteString
    mov edx, OFFSET menu7
    call WriteString
    mov edx, OFFSET menu8
    call WriteString
    mov edx, OFFSET menu9
    call WriteString
    mov edx, OFFSET menu10
    call WriteString

    mov edx, OFFSET promptChoic
    call WriteString
    call ReadInt        ; EAX = choice

    cmp eax, 1
    je do_add
    cmp eax, 2
    je do_display_by_id
    cmp eax, 3
    je do_display_all
    cmp eax, 4
    je do_delete_by_id
    cmp eax, 5
    je do_update_by_id
    cmp eax, 6
    je do_count
    cmp eax, 7
    je do_clear
    cmp eax, 8
    je do_exit
    cmp eax, 9
    je do_search
    cmp eax, 10
    je do_aggregate

    ; invalid choice -> loop
    jmp main_loop

do_add:
    call add_record
    jmp main_loop

do_display_by_id:
    ; Ask for ID
    mov edx, OFFSET addrec3
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString

    push OFFSET inputBuffer
    call display_record      ; display_record will ret 4
    jmp main_loop

do_display_all:
    call display_all
    jmp main_loop

do_delete_by_id:
    mov edx, OFFSET addrec3
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString

    push OFFSET inputBuffer
    call delete_by_id
    jmp main_loop

do_update_by_id:
    mov edx, OFFSET addrec3
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString

    push OFFSET inputBuffer
    call update_by_id
    jmp main_loop

do_count:
    call count_total
    jmp main_loop

do_clear:
    call clear_all
    jmp main_loop

do_search:
    call search_like
    jmp main_loop

do_aggregate:
    call aggregate_menu
    jmp main_loop

do_exit:
    exit
main ENDP

; ========================= ADD_RECORD =========================
add_record PROC
    ; check capacity
    mov eax, countRec
    cmp eax, MAX
    jae add_full    ; if count >= MAX, we cannot add more

    ; get index = countRec
    mov ebx, countRec      ; EBX = index

    ; --- First name ---
    mov edx, OFFSET addrec1
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString

    ; copy inputBuffer -> first_name[index]
    mov eax, ebx
    mov ecx, STRLEN
    mul ecx                ; EAX = index * STRLEN
    lea edi, first_name
    add edi, eax
    mov esi, OFFSET inputBuffer
    mov ecx, STRLEN
    cld
    rep movsb

    ; --- Last name ---
    mov edx, OFFSET addrec2
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString

    mov eax, ebx
    mov ecx, STRLEN
    mul ecx
    lea edi, last_name
    add edi, eax
    mov esi, OFFSET inputBuffer
    mov ecx, STRLEN
    cld
    rep movsb

    ; --- Nu-ID (id_array) ---
    mov edx, OFFSET addrec3
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString

    mov eax, ebx
    mov ecx, STRLEN
    mul ecx
    lea edi, id_array
    add edi, eax
    mov esi, OFFSET inputBuffer
    mov ecx, STRLEN
    cld
    rep movsb

    ; --- attendance ---
    mov edx, OFFSET addrec4
    call WriteString
    call ReadInt
    mov ebx, 0
    mov bl, al
    mov eax, countRec
    mov attendance[eax], bl

    ; --- avg marks ---
    mov edx, OFFSET addrec5
    call WriteString
    call ReadInt
    mov ebx, 0
    mov bl, al
    mov eax, countRec
    mov avg[eax], bl

    ; increment countRec
    mov eax, countRec
    inc eax
    mov countRec, eax

    mov edx, OFFSET savedMsg
    call WriteString
    ret

add_full:
    ; if full, notify and return
    mov edx, OFFSET notFoundMsg
    call WriteString
    ret
add_record ENDP

; ========================= SEARCH (LIKE) =========================
; Asks user for search type, substring (may include % and _), then searches first_name only.
search_like PROC
    push ebp
    mov ebp, esp
    ; locals: none on stack (patternBuf used)

    ; ask for mode
    mov edx, OFFSET searchTypeMsg
    call WriteString
    mov edx, OFFSET searchOpt1
    call WriteString
    mov edx, OFFSET searchOpt2
    call WriteString
    mov edx, OFFSET searchOpt3
    call WriteString

    mov edx, OFFSET promptChoic
    call WriteString
    call ReadInt        ; EAX = choice (1=starts,2=ends,3=contains)
    mov bl, al          ; save search type into BL (1/2/3)

    ; get substring (pattern or plain substring)
    mov edx, OFFSET enterSubMsg
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString

    ; compute input length and also detect if user included % or _
    mov esi, OFFSET inputBuffer
    xor edi, edi        ; edi = inLen
    mov al, 0
    mov ah, 0
    mov dl, 0           ; dl = flag: contains wildcard?
sl_count:
    mov al, [esi + edi]
    cmp al, 0
    je sl_done
    cmp al, '%'
    je sl_mark_wild
    cmp al, '_'
    je sl_mark_wild
    inc edi
    jmp sl_count

sl_mark_wild:
    mov dl, 1           ; wildcard present
    inc edi
    jmp sl_count

sl_done:
    ; EDI = inLen, DL = wildcard flag (1 if input contains % or _)

    ; If input contains wildcards, copy inputBuffer -> patternBuf unchanged
    cmp dl, 1
    je sl_copy_input_as_pattern

    ; else build SQL-style pattern depending on search type:
    ; type 1 => prefix match => pattern = input + '%'
    ; type 2 => suffix match => pattern = '%' + input
    ; type 3 => contains => pattern = '%' + input + '%'
    ; patternBuf size STRLEN+2 is enough

    cmp bl, 1
    je sl_build_prefix
    cmp bl, 2
    je sl_build_suffix
    cmp bl, 3
    je sl_build_contains

    ; default: copy as-is
sl_copy_input_as_pattern:
    ; copy inputBuffer bytes (EDI bytes) into patternBuf
    mov ecx, edi
    mov esi, OFFSET inputBuffer
    mov edi, OFFSET patternBuf
    cld
    rep movsb
    ; null terminate
    mov byte ptr [edi], 0
    ; set pattern length in ESI (reuse)
    mov esi, edi
    sub esi, OFFSET patternBuf
    ; ESI now patternLen but it's pointer math - simpler: set patLen = original in EDI saved earlier
    mov eax, edi
    ; compute patternLen = original inLen (we have it in ???). We'll move inLen to EAX earlier
    ; To simplify, we will store in local register: inLen currently in ??? earlier edi was overwritten by rep movsb,
    ; so instead save original inLen into ECX before copying. Implement above: we used ECX=edi (inLen) before rep movsb.
    ; After rep movsb, ECX becomes 0. But we can store in a register before rep. To avoid complexity, redo copy using loop preserving inLen.

    ; We'll redo copy with registers carefully:
    ; reset: copy properly using saved inLen in stack variable by re-reading inputBuffer length again.

    ; Recompute input length into ECX
    mov esi, OFFSET inputBuffer
    xor ecx, ecx
sl_count2:
    mov al, [esi + ecx]
    cmp al, 0
    je sl_count2_done
    inc ecx
    jmp sl_count2
sl_count2_done:
    mov esi, OFFSET inputBuffer
    mov edi, OFFSET patternBuf
    mov edx, ecx
    cld
    rep movsb
    mov byte ptr [edi], 0
    mov esi, ecx        ; patternLen in ESI
    jmp sl_prepare_call

sl_build_prefix:
    ; copy input then append '%'
    ; compute length EDI currently holds original inLen - recompute
    mov esi, OFFSET inputBuffer
    xor ecx, ecx
sl_bp_cnt:
    mov al, [esi + ecx]
    cmp al, 0
    je sl_bp_done
    inc ecx
    jmp sl_bp_cnt
sl_bp_done:
    mov esi, OFFSET inputBuffer
    mov edi, OFFSET patternBuf
    mov edx, ecx
    cld
    rep movsb              ; copy ecx bytes
    mov byte ptr [edi], '%' ; append '%'
    inc edi
    mov byte ptr [edi], 0  ; null terminator
    mov esi, ecx
    inc esi                ; patternLen = original + 1
    jmp sl_prepare_call

sl_build_suffix:
    ; pattern = '%' + input
    mov esi, OFFSET inputBuffer
    xor ecx, ecx
sl_bs_cnt:
    mov al, [esi + ecx]
    cmp al, 0
    je sl_bs_done
    inc ecx
    jmp sl_bs_cnt
sl_bs_done:
    mov edi, OFFSET patternBuf
    mov byte ptr [edi], '%'
    inc edi
    mov esi, OFFSET inputBuffer
    mov edx, ecx
    cld
    rep movsb
    mov byte ptr [edi], 0
    mov esi, ecx
    inc esi                ; patternLen = original +1
    jmp sl_prepare_call

sl_build_contains:
    ; pattern = '%' + input + '%'
    mov esi, OFFSET inputBuffer
    xor ecx, ecx
sl_bc_cnt:
    mov al, [esi + ecx]
    cmp al, 0
    je sl_bc_done
    inc ecx
    jmp sl_bc_cnt
sl_bc_done:
    mov edi, OFFSET patternBuf
    mov byte ptr [edi], '%'
    inc edi
    mov esi, OFFSET inputBuffer
    mov edx, ecx
    cld
    rep movsb
    mov byte ptr [edi], '%'
    inc edi
    mov byte ptr [edi], 0
    mov esi, ecx
    add esi, 2             ; patternLen = original + 2
    jmp sl_prepare_call

; after copying -> pattern pointer in patternBuf; patternLen in ESI
sl_prepare_call:
    ; ESI currently holds patternLen
    ; We'll call match_like for each first_name record:
    mov ebx, 0            ; record index
    mov ecx, countRec
    cmp ecx, 0
    je sl_no_records

sl_search_loop:
    cmp ebx, ecx
    jge sl_done_all

    ; check first_name slot exists (first char != 0)
    mov eax, ebx
    mov edx, STRLEN
    mul edx
    lea edi, first_name
    add edi, eax
    mov al, [edi]
    cmp al, 0
    je sl_next_rec

    ; call match_like with params order expected by match_like:
    ; push subLen; push subPtr; push namePtr; push type
    push esi                ; patternLen
    push OFFSET patternBuf  ; pattern ptr
    ; namePtr = address of first_name[ebx]
    mov eax, ebx
    mov edx, STRLEN
    mul edx
    lea eax, first_name
    add eax, edx
    push eax                ; namePtr
    movzx eax, bl
    push eax                ; type (keeps original menu meaning but pattern handles %/_)
    call match_like
    add esp, 16
    cmp al, 1
    jne sl_next_rec

    ; match -> show record
    push ebx
    call show_record_at_index
    add esp, 4

sl_next_rec:
    inc ebx
    jmp sl_search_loop

sl_done_all:
    jmp sl_finish

sl_no_records:
    mov edx, OFFSET notFoundMsg
    call WriteString
    call Crlf

sl_finish:
    pop ebp
    ret
search_like ENDP

; ---------------------------------------------------------
; match_like PROC - SQL-style wildcard matcher
; Caller pushes: push subLen; push subPtr; push namePtr; push type
; Stack layout:
; [ebp+8]  = type  (we will ignore this for wildcard matching; pattern controls behavior)
; [ebp+12] = namePtr
; [ebp+16] = patternPtr
; [ebp+20] = patternLen
; Returns: AL = 1 if match else AL = 0 (case-insensitive; % and _ supported)
; ---------------------------------------------------------
match_like PROC
    push ebp
    mov ebp, esp
    sub esp, 8              ; locals: [ebp-4] = lastStarPat (int), [ebp-8] = lastStarStr (int)

    mov esi, DWORD PTR [ebp + 12]   ; namePtr
    mov edi, DWORD PTR [ebp + 16]   ; patternPtr
    mov edx, DWORD PTR [ebp + 20]   ; patternLen

    xor ebx, ebx            ; patIdx = 0
    xor ecx, ecx            ; strIdx = 0

    mov DWORD PTR [ebp-4], -1    ; lastStarPat = -1
    mov DWORD PTR [ebp-8], -1    ; lastStarStr = -1

ml_loop:
    ; if patIdx < patternLen get patChar
    mov eax, ebx
    cmp eax, edx
    jae .pat_end_check

    mov al, [edi + ebx]        ; pattern char in AL
    cmp al, '%'
    je .pat_percent
    cmp al, '_'
    je .pat_underscore

    ; normal literal char: need to compare with name char
    mov dl, [esi + ecx]        ; name char in DL
    cmp dl, 0
    je .try_backtrack         ; name ended => try backtrack or fail

    ; case-insensitive normalize both to uppercase A-Z
    mov al, al
    cmp al, 'a'
    jb .skip_pat_norm
    cmp al, 'z'
    ja .skip_pat_norm
    sub al, 32
.skip_pat_norm:
    mov dl, dl
    cmp dl, 'a'
    jb .skip_name_norm
    cmp dl, 'z'
    ja .skip_name_norm
    sub dl, 32
.skip_name_norm:

    cmp al, dl
    jne .try_backtrack_ok        ; not equal -> try backtrack
    ; equal: advance both
    inc ebx
    inc ecx
    jmp ml_loop

.pat_percent:
    ; record star position and the corresponding string position
    mov DWORD PTR [ebp-4], ebx   ; lastStarPat = patIdx
    mov DWORD PTR [ebp-8], ecx   ; lastStarStr = strIdx
    inc ebx                      ; advance pattern past '%'
    jmp ml_loop

.pat_underscore:
    ; '_' matches any single character if available
    mov dl, [esi + ecx]
    cmp dl, 0
    je .try_backtrack
    inc ebx
    inc ecx
    jmp ml_loop

.try_backtrack_ok:
    ; backtrack if previous '%' exist
    mov eax, DWORD PTR [ebp-4]
    cmp eax, -1
    je .no_match
    ; advance lastStarStr by 1; set strIdx = lastStarStr; patIdx = lastStarPat+1
    mov eax, DWORD PTR [ebp-8]
    inc eax
    mov DWORD PTR [ebp-8], eax
    mov ecx, eax
    mov eax, DWORD PTR [ebp-4]
    mov ebx, eax
    inc ebx
    jmp ml_loop

.try_backtrack:
    mov eax, DWORD PTR [ebp-4]
    cmp eax, -1
    je .no_match
    ; backtrack like above
    mov eax, DWORD PTR [ebp-8]
    inc eax
    mov DWORD PTR [ebp-8], eax
    mov ecx, eax
    mov eax, DWORD PTR [ebp-4]
    mov ebx, eax
    inc ebx
    jmp ml_loop

.pat_end_check:
    ; reached end of pattern: ensure remaining pattern chars (if any) are all '%'
    mov eax, ebx
.check_trailing:
    cmp eax, edx
    jae .check_str_end
    mov al, [edi + eax]
    cmp al, '%'
    je .inc_trail
    ; non-% trailing char => not match unless we can backtrack
    ; try backtrack:
    mov eax, DWORD PTR [ebp-4]
    cmp eax, -1
    je .no_match
    ; backtrack
    mov eax, DWORD PTR [ebp-8]
    inc eax
    mov DWORD PTR [ebp-8], eax
    mov ecx, eax
    mov eax, DWORD PTR [ebp-4]
    mov ebx, eax
    inc ebx
    jmp ml_loop
.inc_trail:
    inc eax
    jmp .check_trailing

.check_str_end:
    ; if we consumed full pattern (only % remain) match
    ; also it's OK if name still has characters (because trailing '%' can absorb them)
    ; But need to ensure that if pattern has no trailing '%', then name must be at end
    ; After removing trailing %, if pattern ended: success
    ; Determine final: we already skipped trailing %, so success
    mov al, 1
    jmp ml_done

.no_match:
    xor eax, eax
    mov al, 0
    jmp ml_done

ml_done:
    ; restore stack and return AL
    add esp, 8
    pop ebp
    ret
match_like ENDP

; ========================= show_record_at_index =========================
; parameter: [ebp+8] index (DWORD)
; prints first_name, last_name, attendance, avg for index
show_record_at_index PROC
    push ebp
    mov ebp, esp

    mov esi, DWORD PTR [ebp + 8]    ; index
    ; first_name
    mov eax, esi
    mov edx, STRLEN
    mul edx
    lea edx, first_name
    add edx, eax
    call WriteString
    call Crlf

    ; last_name
    mov eax, esi
    mov edx, STRLEN
    mul edx
    lea edx, last_name
    add edx, eax
    call WriteString
    call Crlf

    ; attendance
    mov eax, esi
    movzx eax, attendance[eax]
    call WriteDec
    call Crlf

    ; avg
    mov eax, esi
    movzx eax, avg[eax]
    call WriteDec
    call Crlf

    pop ebp
    ret 4
show_record_at_index ENDP

; ========================= DISPLAY_BY_ID (parameter passed as OFFSET inputBuffer) =========================
; parameter: [ebp + 8] -> pointer to ID string to search
display_record PROC
    push ebp
    mov ebp, esp

    mov esi, DWORD PTR [ebp + 8]   ; esi -> target ID string pointer
    ; index loop
    mov ecx, countRec
    cmp ecx, 0
    je dr_not_found
    mov ebx, 0                     ; index

dr_loop:
    cmp ebx, ecx
    jge dr_not_found

    ; compute address of id_array[ebx]
    mov eax, ebx
    mov edx, STRLEN
    mul edx                         ; EAX = index * STRLEN
    lea edi, id_array
    add edi, eax                    ; edi -> id_array[index]

    ; safe byte-by-byte compare (null-terminated or up to STRLEN)
    mov esi, DWORD PTR [ebp + 8]    ; pointer to search key again
    mov edx, STRLEN
compare_loop:
    mov al, [esi]
    mov bl, [edi]
    cmp al, bl
    jne not_equal_dr
    cmp al, 0
    je dr_found
    inc esi
    inc edi
    dec edx
    jnz compare_loop

    ; if we exhausted STRLEN and all matched -> found
    jmp dr_found

not_equal_dr:
    inc ebx
    jmp dr_loop

dr_found:
    ; show first_name[index]
    push ebx
    call show_record_at_index
    add esp, 4

    pop ebp
    ret 4

dr_not_found:
    mov edx, OFFSET notFoundMsg
    call WriteString
    call Crlf
    pop ebp
    ret 4
display_record ENDP

; ========================= DISPLAY ALL =========================
display_all PROC
    mov ecx, countRec
    cmp ecx, 0
    je da_empty

    mov ebx, 0
da_loop:
    cmp ebx, ecx
    jge da_done

    push ebx
    call show_record_at_index
    add esp, 4

    inc ebx
    jmp da_loop

da_done:
    ret

da_empty:
    mov edx, OFFSET notFoundMsg
    call WriteString
    ret
display_all ENDP

; ========================= DELETE BY ID =========================
; parameter: [ebp + 8] -> pointer to ID string
delete_by_id PROC
    push ebp
    mov ebp, esp

    mov esi, DWORD PTR [ebp + 8]   ; search key
    mov ecx, countRec
    cmp ecx, 0
    je del_not_found
    mov ebx, 0                     ; index

del_loop:
    cmp ebx, ecx
    jge del_not_found

    ; compute slot address id_array[ebx]
    mov eax, ebx
    mov edx, STRLEN
    mul edx
    lea edi, id_array
    add edi, eax

    ; compare
    mov esi, DWORD PTR [ebp + 8]
    mov edx, STRLEN
compare_del:
    mov al, [esi]
    mov bl, [edi]
    cmp al, bl
    jne not_equal_del
    cmp al, 0
    je del_found
    inc esi
    inc edi
    dec edx
    jnz compare_del
    jmp del_found

not_equal_del:
    inc ebx
    jmp del_loop

del_found:
    ; If deleting last element just decrement countRec
    mov eax, countRec
    dec eax                ; lastIndex = countRec - 1
    cmp eax, ebx
    je del_last_one

    ; copy last record into slot ebx
    ; copy first_name
    mov esi, countRec
    dec esi
    mov eax, esi
    mov ecx, STRLEN
    mul ecx
    lea esi, first_name
    add esi, eax    ; source

    mov eax, ebx
    mov ecx, STRLEN
    mul ecx
    lea edi, first_name
    add edi, eax    ; dest
    mov ecx, STRLEN
    cld
    rep movsb

    ; copy last_name
    mov esi, countRec
    dec esi
    mov eax, esi
    mov ecx, STRLEN
    mul ecx
    lea esi, last_name
    add esi, eax

    mov eax, ebx
    mov ecx, STRLEN
    mul ecx
    lea edi, last_name
    add edi, eax
    mov ecx, STRLEN
    cld
    rep movsb

    ; copy id_array
    mov esi, countRec
    dec esi
    mov eax, esi
    mov ecx, STRLEN
    mul ecx
    lea esi, id_array
    add esi, eax

    mov eax, ebx
    mov ecx, STRLEN
    mul ecx
    lea edi, id_array
    add edi, eax
    mov ecx, STRLEN
    cld
    rep movsb

    ; copy attendance & avg
    mov eax, countRec
    dec eax
    mov al, attendance[eax]
    mov attendance[ebx], al
    mov al, avg[eax]
    mov avg[ebx], al

    ; decrement countRec
    mov eax, countRec
    dec eax
    mov countRec, eax

    mov edx, OFFSET delMsg
    call WriteString
    pop ebp
    ret 4

del_last_one:
    ; deleting last element: just decrement count
    mov eax, countRec
    dec eax
    mov countRec, eax
    mov edx, OFFSET delMsg
    call WriteString
    pop ebp
    ret 4

del_not_found:
    mov edx, OFFSET notFoundMsg
    call WriteString
    call Crlf
    pop ebp
    ret 4

delete_by_id ENDP

; ========================= UPDATE BY ID =========================
; parameter: [ebp + 8] -> pointer to ID string
update_by_id PROC
    push ebp
    mov ebp, esp

    mov esi, DWORD PTR [ebp + 8]
    mov ecx, countRec
    cmp ecx, 0
    je upd_not_found
    mov ebx, 0

upd_loop:
    cmp ebx, ecx
    jge upd_not_found

    ; compute address of id_array[ebx]
    mov eax, ebx
    mov edx, STRLEN
    mul edx
    lea edi, id_array
    add edi, eax

    ; compare
    mov esi, DWORD PTR [ebp + 8]
    mov edx, STRLEN
upd_compare_loop:
    mov al, [esi]
    mov bl, [edi]
    cmp al, bl
    jne upd_not_equal
    cmp al, 0
    je upd_found
    inc esi
    inc edi
    dec edx
    jnz upd_compare_loop
    jmp upd_found

upd_not_equal:
    inc ebx
    jmp upd_loop

upd_found:
    ; ask and overwrite same slot (first_name, last_name, attendance, avg)
    ; first_name
    mov edx, OFFSET addrec1
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString
    mov eax, ebx
    mov ecx, STRLEN
    mul ecx
    lea edi, first_name
    add edi, eax
    mov esi, OFFSET inputBuffer
    mov ecx, STRLEN
    cld
    rep movsb

    ; last_name
    mov edx, OFFSET addrec2
    call WriteString
    mov edx, OFFSET inputBuffer
    mov ecx, SIZEOF inputBuffer
    call ReadString
    mov eax, ebx
    mov ecx, STRLEN
    mul ecx
    lea edi, last_name
    add edi, eax
    mov esi, OFFSET inputBuffer
    mov ecx, STRLEN
    cld
    rep movsb

    ; attendance
    mov edx, OFFSET addrec4
    call WriteString
    call ReadInt
    mov eax, ebx
    mov attendance[eax], al

    ; avg
    mov edx, OFFSET addrec5
    call WriteString
    call ReadInt
    mov eax, ebx
    mov avg[eax], al

    mov edx, OFFSET updMsg
    call WriteString
    pop ebp
    ret 4

upd_not_found:
    mov edx, OFFSET notFoundMsg
    call WriteString
    call Crlf
    pop ebp
    ret 4
update_by_id ENDP

; ========================= COUNT TOTAL =========================
count_total PROC
    mov eax, countRec
    mov edx, OFFSET countMsg
    call WriteString
    mov eax, countRec
    call WriteDec
    call Crlf
    ret
count_total ENDP

; ========================= CLEAR ALL =========================
clear_all PROC
    ; zero count and zero arrays (optional: we just set count to 0)
    mov countRec, 0
    mov edx, OFFSET clearMsg
    call WriteString
    call Crlf
    ret
clear_all ENDP

; ========================= AGGREGATE MENU & FUNCTIONS =========================
aggregate_menu PROC
    push ebp
    mov ebp, esp

    mov edx, OFFSET aggrMsg
    call WriteString
    mov edx, OFFSET aggrOpt1
    call WriteString
    mov edx, OFFSET aggrOpt2
    call WriteString
    mov edx, OFFSET aggrOpt3
    call WriteString
    mov edx, OFFSET aggrOpt4
    call WriteString

    mov edx, OFFSET promptChoic
    call WriteString
    call ReadInt     ; EAX = choice of aggregate
    cmp eax, 1
    je aggr_min
    cmp eax, 2
    je aggr_max
    cmp eax, 3
    je aggr_count
    cmp eax, 4
    je aggr_avg

    ; else return
    pop ebp
    ret
aggregate_menu ENDP

; helper: get_column_choice -> returns in BL (1 attendance, 2 marks)
get_column_choice PROC
    push ebp
    mov ebp, esp

    mov edx, OFFSET colMsg
    call WriteString
    call ReadInt
    mov bl, al

    pop ebp
    ret
get_column_choice ENDP

; aggr_min: find min value in selected column
aggr_min PROC
    push ebp
    mov ebp, esp

    call get_column_choice
    ; BL = column

    ; initialize minVal to 255
    mov ah, 0FFh
    mov al, 0FFh
    movzx eax, ax
    mov esi, 0      ; index
    mov ebx, 0      ; reuse ebx as temp, but BL currently holds column - save later if needed
    mov edx, 0FFh   ; min in DL (we'll use AL at end)

    mov ecx, countRec
    cmp ecx, 0
    je aggr_min_empty

min_loop:
    cmp esi, ecx
    jge min_done

    ; check record exists (id_array first byte != 0)
    mov eax, esi
    mov edx, STRLEN
    mul edx
    lea edi, id_array
    add edi, eax
    mov al, [edi]
    cmp al, 0
    je min_next

    ; load chosen column value into al
    mov al, 0
    cmp bl, 1
    je min_att
    ; else marks (avg)
    movzx eax, avg[esi]
    jmp min_check

min_att:
    movzx eax, attendance[esi]

min_check:
    cmp dl, 0FFh
    je set_min_initial

    mov dl, dl      ; no-op to access DL
    ; compare current value (in AL) with DL
    mov cl, dl
    cmp al, cl
    jge min_next    ; if al >= current min skip
    mov dl, al
    jmp min_next

set_min_initial:
    ; set initial min to current al
    mov dl, al

min_next:
    inc esi
    jmp min_loop

min_done:
    ; if DL still 0FFh then no records found (shouldn't happen if countRec>0)
    cmp dl, 0FFh
    je aggr_min_empty

    movzx eax, dl
    ; print result
    mov edx, OFFSET menuMsg    ; small header
    call WriteString
    mov edx, OFFSET promptChoic
    call WriteString
    mov eax, 0
    movzx eax, dl

    call WriteDec
    call Crlf

    pop ebp
    ret

aggr_min_empty:
    mov edx, OFFSET notFoundMsg
    call WriteString
    call Crlf
    pop ebp
    ret
aggr_min ENDP

; aggr_max: find max value in selected column
aggr_max PROC
    push ebp
    mov ebp, esp

    call get_column_choice
    ; BL = column

    mov esi, 0
    mov ecx, countRec
    cmp ecx, 0
    je aggr_max_empty

    mov bh, 0  ; will hold initial flag (0=not set, 1=set)
    mov dl, 0  ; max in DL

max_loop:
    cmp esi, ecx
    jge max_done

    ; check record exists
    mov eax, esi
    mov edx, STRLEN
    mul edx
    lea edi, id_array
    add edi, eax
    mov al, [edi]
    cmp al, 0
    je max_next

    ; load value
    cmp bl, 1
    je max_att
    movzx eax, avg[esi]
    jmp max_check

max_att:
    movzx eax, attendance[esi]

max_check:
    mov dl, al
    cmp bh, 1
    je max_compare
    ; first valid value
    mov bh, 1
    mov cl, dl
    jmp max_next

max_compare:
    cmp dl, cl
    jle max_next
    mov cl, dl

max_next:
    inc esi
    jmp max_loop

max_done:
    cmp bh, 1
    jne aggr_max_empty

    ; print CL (max)
    movzx eax, cl
    mov edx, OFFSET menuMsg
    call WriteString
    mov edx, OFFSET promptChoic
    call WriteString
    movzx eax, cl
    call WriteDec
    call Crlf

    pop ebp
    ret

aggr_max_empty:
    mov edx, OFFSET notFoundMsg
    call WriteString
    call Crlf
    pop ebp
    ret
aggr_max ENDP

; aggr_count: print number of active records (countRec is accurate)
aggr_count PROC
    push ebp
    mov ebp, esp

    mov edx, OFFSET countMsg
    call WriteString
    mov eax, countRec
    call WriteDec
    call Crlf

    pop ebp
    ret
aggr_count ENDP

; aggr_avg: average of selected column
aggr_avg PROC
    push ebp
    mov ebp, esp

    call get_column_choice
    ; BL = column

    xor eax, eax
    xor edx, edx
    xor ecx, ecx        ; ecx = count
    mov esi, 0
    mov ebx, countRec
    cmp ebx, 0
    je aggr_avg_empty

avg_loop:
    cmp esi, ebx
    jge avg_done

    ; check if record exists
    mov eax, esi
    mov edx, STRLEN
    mul edx
    lea edi, id_array
    add edi, eax
    mov al, [edi]
    cmp al, 0
    je avg_next

    ; load chosen value into EDX (use EDX for value) and add to sum (EAX used for sum)
    cmp bl, 1
    je avg_att
    movzx edx, avg[esi]
    jmp avg_add

avg_att:
    movzx edx, attendance[esi]

avg_add:
    add eax, edx
    inc ecx

avg_next:
    inc esi
    jmp avg_loop

avg_done:
    cmp ecx, 0
    je aggr_avg_empty

    ; compute integer average EAX / ECX
    mov edx, 0
    ; EAX holds sum, ECX holds count
    ; divisor in ECX
    ; use DIV: dividend in EDX:EAX
    div ecx

    ; save quotient (in EAX) to EBX to preserve across WriteString calls
    mov ebx, eax

    mov edx, OFFSET menuMsg
    call WriteString
    mov edx, OFFSET promptChoic
    call WriteString

    mov eax, ebx
    call WriteDec
    call Crlf

    pop ebp
    ret

aggr_avg_empty:
    mov edx, OFFSET notFoundMsg
    call WriteString
    call Crlf
    pop ebp
    ret
aggr_avg ENDP

END main
